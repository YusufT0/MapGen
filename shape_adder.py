import trimesh
import numpy as np
import pymeshlab

    


def create_model(bounds, base_mesh, aug: dict) -> trimesh.Trimesh:
    def rotate_to_y(mesh):
        rot = trimesh.transformations.rotation_matrix(np.pi / 2, [-1, 0, 0])
        mesh.apply_transform(rot)
        return mesh
    
    def custom_loading():
        mesh = trimesh.load(aug.get('custom_path'))
        mesh.apply_scale(aug['scale'])
        mesh.visual.material = mesh.visual.material  
        return mesh


    def create_shape(shape_func, scale_offset_func):
        
        count = aug.get('count', 1)
        position = aug.get('position', 'random')
        shapes = []

        for i in range(count):
            shape = shape_func()
            
            # Apply rotation for spheres, cylinders, and cones
            # Shapes generated by trimesh are looking to z-axis. For the bottom of the shape to be on the ground we rotate the shape in x axis.
            if aug['model'] in ['sphere', 'cylinder', 'cone']:
                rotate_to_y(shape)

            if aug['model'] != "custom":
                shape.visual.face_colors = aug['color'] * np.ones(4)


            if position == "random":
                trigger = True
                while trigger:
                    x, y, z = create_random_xyz(bounds)
                    conf_y = control_random_creation(x, y, z, base_mesh)
                    final_y = conf_y + scale_offset_func()
                    updated_coords = [x, final_y, z]
                    trigger = control_collision(updated_coords, shapes)
                shape.apply_translation(updated_coords)
                    
            else:
                shape.apply_translation(position * np.ones(3))
        
            shapes.append(shape)

        return shapes

    shape_configs = {
        'cube': {
            'shape_func': lambda: trimesh.creation.box(extents=aug.get('scale', 5.0) * np.ones(3)),
            'offset_func': lambda: aug.get('scale', 5.0) / 2
        },
        'sphere': {
            'shape_func': lambda: trimesh.creation.icosphere(radius=aug.get('scale', 5.0)),
            'offset_func': lambda: aug.get('scale', 5.0)
        },
        'cylinder': {
            'shape_func': lambda: trimesh.creation.cylinder(
                radius=aug.get('scale', 2.0), 
                height=aug.get('height', 5.0)
            ),
            'offset_func': lambda: aug.get('scale', 5.0) / 2
        },
        'cone': {
            'shape_func': lambda: trimesh.creation.cone(
                radius=aug.get('scale', 2.0), 
                height=aug.get('height', 5.0)
            ),
            'offset_func': lambda: aug.get('scale', 5.0) / 2
        },
        'custom':{
            'shape_func': custom_loading,
            'offset_func': lambda: 0  
            }
    }

    model_type = aug['model']
    
    config = shape_configs[model_type]
    return create_shape(config['shape_func'], config['offset_func'])


# This is a helper function to see where are the shapes are going to be attached when the control mechanism works.

def visualize_ray(scene, origin, direction, length=10.0, hit_points=None):

    origin = np.array(origin)
    direction = np.array(direction).flatten()  # Flatten in case it's 2D
    
    end_point = origin + direction * length
    ray_length = np.linalg.norm(end_point - origin)
    
    cylinder = trimesh.creation.cylinder(radius=0.02, height=ray_length)
    
    z_axis = np.array([0, 0, 1])
    if not np.allclose(direction, z_axis):
        rotation_axis = np.cross(z_axis, direction)
        if np.linalg.norm(rotation_axis) > 1e-6:  # Avoid division by zero
            rotation_axis = rotation_axis / np.linalg.norm(rotation_axis)
            angle = np.arccos(np.clip(np.dot(z_axis, direction), -1, 1))
            rotation_matrix = trimesh.transformations.rotation_matrix(angle, rotation_axis)
            cylinder.apply_transform(rotation_matrix)
    
    # Translate to the midpoint of the ray
    midpoint = origin + direction * (ray_length / 2)
    cylinder.apply_translation(midpoint)
    
    scene.add_geometry(cylinder)
    
    # Add hit points as small spheres
    if hit_points is not None and len(hit_points) > 0:
        for pt in hit_points:
            sphere = trimesh.creation.uv_sphere(radius=0.1)
            sphere.apply_translation(pt)
            
            scene.add_geometry(sphere)


def control_collision(coords, shapes):
    for shape in shapes:

        min_bound, max_bound = shape.bounds
        radius = 0.1

        coords_min = np.array(coords) - radius
        coords_max = np.array(coords) + radius

        overlap = True
        for i in range(3):
            if coords_max[i] < min_bound[i] or coords_min[i] > max_bound[i]:
                overlap = False
                break
        if overlap:
            return True  
    return False  


def control_random_creation(x, y, z, mesh_for_query):
    offset = 0.01
    sceneCenter = 0
    if y < sceneCenter:
        ray_direction = np.array([0, 1, 0])  # Work in y axis 
        ray_origin = np.array([x, y - offset, z])  
    else:
        ray_direction = np.array([0, -1, 0])   
        ray_origin = np.array([x, y + offset, z])  

    locations, index_ray, index_tri = mesh_for_query.ray.intersects_location(
        ray_origins=[ray_origin],
        ray_directions=[ray_direction]  
    )

    # visualize_ray(scene, ray_origin, ray_direction, length=20.0, hit_points=locations)

    # Check if we have any intersections at all
    if len(locations) > 0:
        # Find the closest intersection point to the ray origin
        distances = np.linalg.norm(locations - ray_origin, axis=1)
        closest_idx = np.argmin(distances)
        closest_intersection = locations[closest_idx]
        
        print(f"Ray hit the mesh at: {closest_intersection}")
        return closest_intersection[1]  # Return Y coordinate of intersection
    else:
        # No intersections found, use nearest point on surface
        closest_point, distance, face_id = mesh_for_query.nearest.on_surface([ray_origin])
        print(f"No ray intersection, using nearest surface point: {closest_point[0]}")
        return closest_point[0][1]


def create_random_xyz(map_bounds):
    x = np.random.uniform(map_bounds[0][0], map_bounds[1][0])
    y = np.random.uniform(map_bounds[0][1], map_bounds[1][1])
    z = np.random.uniform(map_bounds[0][2], map_bounds[1][2])
    return x,y,z
